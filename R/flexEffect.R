#' Flexible Causal Path-Specific Effect Estimation
#'
#' This function estimates causal path-specific effects by comparing two potential outcome objects generated from the \code{flexPotential} or \code{mflexPotential} functions.
#' The effects can be estimated on different scales, including difference ("diff"), risk ratio ("risk"), and odds ratio ("oddsratio").
#' The function also supports bootstrapping for estimating confidence intervals and p-values.
#'
#' @param p1 An object or a list of objects of class \code{flexPotential} or \code{mflexPotential} generated by the \code{flexPotential} or \code{mflexPotential} function, representing one set of potential outcomes.
#' @param p0 An object or a list of objects of class \code{flexPotential} or \code{mflexPotential} generated by the \code{flexPotential} or \code{mflexPotential} function, representing another set of potential outcomes for comparison.
#' Note: \code{p1} and \code{p0} should have the same length; otherwise, one of them must contain a single potential outcome object.
#' @param scale A character string specifying the scale for effect estimation. Options are "diff" (difference), "risk" (risk ratio), and "oddsratio" (odds ratio). The default is "diff".
#' @param CI_level A numeric value indicating the confidence level for the confidence intervals, typically set between 0 and 1. The default is 0.95 for 95% confidence intervals.
#' @param nboot An optional numeric value specifying the number of bootstrap samples to draw for estimating the standard errors and confidence intervals. If NULL, no bootstrapping is performed.
#' @param m.cores An optional numeric value indicating the number of cores to use for parallel processing during bootstrapping. If NULL, the function will use a single core.
#'
#' @return An object of class \code{flexEffect}, which includes the following components:
#' \describe{
#'   \item{\code{pathsFit}}{The original \code{pathsFit} object used for the analysis.}
#'   \item{\code{results}}{A data frame containing the estimated effects for each path, including the effect size, standard error, confidence intervals, and p-values (for the "diff" scale).}
#'   \item{\code{data}}{The original data frame used for the analysis.}
#'   \item{\code{boot_results}}{If bootstrapping is performed, a data frame containing the bootstrap estimates of the effects, including standard errors, confidence intervals, and p-values.}
#'   \item{\code{call}}{The matched call to the \code{flexEffect} function.}
#' }
#'
#' @examples
#' # Example usage
#' data("singTreat")
#'
#' fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome1", cov_x = c("X1", "X2"),
#'                 M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
#'                 estimation = "EIF",
#'                 model.outcome = list(~ glm(family = gaussian())),
#'                 model.propensity = ~ bart(verbose = FALSE, ndpost = 200))
#'
#' potential_outcome1 <- flexPotential( pathsFit = fit, active = c(1, 0, 1, 1))
#' potential_outcome2 <- flexPotential( pathsFit = fit, active = c(0, 1, 0, 1))
#' potential_outcome0 <- flexPotential( pathsFit = fit, active = c(0, 0, 0, 0))
#'
#' effect_results <- flexEffect(p1 = list(potential_outcome1, potential_outcome2),
#'                              p0 = potential_outcome0, scale = "diff", CI_level = 0.95)
#'
#' @import stats purrr dplyr
#' @import SuperLearner dbarts
#' @importFrom parallel mclapply detectCores
#'
#' @export
#'
flexEffect<-function(
    p1 ,
    p0 ,
    scale = "diff", CI_level = 0.95,
    nboot = NULL, m.cores = NULL){

  # environment
  Call <- match.call()

  # 1. check the input p1 and p0 -----
  ## (1) to check one input -------
  if(is.null(p1$call)){len_p1 <- length(p1) }else{
    p1 = list(p1)
    len_p1 <- length(p1)}
  if(is.null(p0$call)){len_p0 <- length(p0)}else{
    p0 = list(p0)
    len_p0 <- length(p0)}

  if (len_p1 != len_p0) {
    # 2. If lengths differ, one of them must have exactly one input
    if (len_p1 == 1) {
      p1 <- rep(p1, len_p0)
    } else if (len_p0 == 1) {
      p0 <- rep(p0, len_p1)
    } else {
      stop("p1 and p0 must have the same length or one of them must have only one input.")
    }
  }


  ## (2). Check that the Call components of p1, and p0 ----
  # same class flexPotential or mflexPotential
   class_p = map_chr(c(p1, p0), ~ class(.x) )

   if(length(unique(class_p))!=1){
     stop("All elements in p1 and p0 must have the same class.")
   }
   if(!unique(class_p)%in% c("flexPotential","mflexPotential") ){
     stop("All elements in p1 and p0 the class must be either 'flexPotential' or 'mflexPotential'.")

   }


  # they have the pathsFit
  pathsFit_p1 <- map(p1, ~.x$pathsFit)
  pathsFit_p0 <- map(p0, ~.x$pathsFit)

  if (!all(map_lgl(pathsFit_p1, ~identical(.x, pathsFit_p0[[1]])))) {
    stop("All inputs in p1 and p0 must have the same 'pathsFit' in their Call component.")
  }

  # 2. the results of EIF
  results <- map2_dfr(p1, p0, ~{
    active <- paste(.x$results$active , "vs" ,.y$results$active)

    if (scale == "diff"){
    diff <- .x$potential_data - .y$potential_data
    Effect <- mean(diff, na.rm = TRUE)
    SE <- sqrt(var(diff, na.rm = TRUE) / length(diff))
    CI.lower <- Effect + qnorm((1 - CI_level) / 2) * SE
    CI.upper <- Effect - qnorm((1 - CI_level) / 2) * SE
    P.value <- round(2 * (1 - pnorm(abs(Effect / SE))), 4)

    # Return the results as a data frame row
    out<-data.frame(active =active,Effect = Effect, SE = SE, CI.lower = CI.lower, CI.upper = CI.upper, P.value = P.value)
    }

    if (scale == "risk"){
    Effect <- mean(.x$potential_data, na.rm = TRUE)/mean(.y$potential_data, na.rm = TRUE)
    # Return the results as a data frame row
    out<-data.frame(active =active,Effect = Effect)
    }

    if (scale == "oddsratio"){
      m1 <- mean(.x$potential_data, na.rm = TRUE)
      m2 <- mean(.y$potential_data, na.rm = TRUE)
      Effect <- (m1/(1-m1))/(m2/(1-m2))

      out<- data.frame(active =active,Effect = Effect)
    }

    return(out) })

  data_raw = p1[[1]]$pathsFit$data; pathsFit = p1[[1]]$pathsFit
  out<- list(pathsFit =pathsFit,
             results =arrange(results,by=active),
             data = data_raw)

  # 2. get the summary of identical calculation ----
  # check_SuperLearner return warning
  if(!is.null(nboot)){

  # aviod replicate calculation to save time
  call_p1 <- map(p1, ~.x$call)
  call_p0 <- map(p0, ~.x$call)
  call_all<-unique(c(call_p1,call_p0))

  index_p1 <- map_int(call_p1, function(index) {
    which(map_lgl(call_all, ~ identical(.x, index)))
  })
  index_p0 <- map_int(call_p0, function(index) {
    which(map_lgl(call_all, ~ identical(.x, index)))
  })

  # bootstrap
  if (is.numeric(m.cores)) {
    m.cores.detected <- parallel::detectCores()
    if(m.cores > m.cores.detected) m.cores <- m.cores.detected

    boot.list <- parallel::mclapply(seq_len(nboot), function(i) {
      one_boot.flexEffect(data_raw, pathsFit, call_all, index_p1, index_p0)}, mc.cores = m.cores)
  }else{
    boot.list = map(seq_len(nboot),
                    ~one_boot.flexEffect(data_raw, pathsFit, call_all, index_p1, index_p0))
  }

  results.combine <- map_dfr(boot.list, ~ .x , .id = "source")
  output<- results.combine %>%
    mutate(
    #  scale = scale,
      Effect = case_when(scale == "diff"~ (value1-value0),
                         scale == "risk"~ (value1/value0),
                         scale == "oddsratio"~ (value1/(1-value1))/(value0/(1-value0)))
    ) %>%
    group_by(active) %>%
    summarise(
      boot.SE = sd(Effect),
      boot.CI.lower = quantile(Effect, probs = (1-CI_level)/2),
      boot.CI.upper = quantile(Effect, probs = 1-(1-CI_level)/2)) %>%
    full_join(select(results, active, Effect), by = join_by(active)) %>%
    mutate(boot.P.value = round(2*(1-pnorm(abs(Effect)/boot.SE)),4),
           nboot = nboot) %>%
    relocate(Effect, .after = active) %>% as.data.frame()

  out$boot_results <- output


  }

  out$call <- Call
  class(out) <- "flexEffect"
  return(out)

}


