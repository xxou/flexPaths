#'     c(1, 0, 1, 1, 1, 0, 0),      # Treatment2
#'     c(NA, NA, NA, 1, 0, 0, 0)    # Treatment3
#'   )
#' )
#'
#' @import stats purrr
#' @import SuperLearner dbarts
#'
#' @export
mflexPotential <-  function(
pathsFit,active
){
cl <- match.call()
list2env(pathsFit, envir = environment())
#### 1. data preparation ---------
## cov_x and mediators
N= nrow(data)
Km <- length(M.list)
# combine mediators
# mediators for model
active_m <- do.call(rbind, active)
M.index <- mcreate_index(active_m)[-(Km + 1)]
M.list_s <- combine_item(M.list, M.index)
cum_mediators <- cumulate_vars(c(cov_x,M.list_s))
# treatment value for model
active_s <- simplify_active(active_m)
# treatment variables list; assigned value list
a.list <- map(seq_len(ncol(active_s)), ~ A[which(!is.na(active_s[, .x]))])
active_s.list<-map(1:ncol(active_s), ~ as.numeric(na.omit(active_s[, .x])))
# cumulative expression for model
cum_a.list <- map(a.list,~cumulate_vars(.x,first_null = T))
cum_active_s.list<-map(active_s.list,~cumulate_vars(.x,first_null = T))
K = length(cum_mediators)
#### 2. outcome model  ----------
if(estimation != "IPW"){
out.details<- map(Omodel.lists,extract_model_details)
out.fit_names <- map(out.details, ~ paste0("fl_", .x$fit_name))
out.calls <-  map(out.details, "model_call")
iter.details<- map(Imodel.lists,extract_model_details)
iter.fit_names <- map(iter.details, ~ paste0("fl_", .x$fit_name))
iter.calls <- map(iter.details, "model_call")
iter.calls <-map(iter.args, ~ replace_family(.x))
fit_names <- c(rep(iter.fit_names,K-1), out.fit_names)
mu.calls <- c(rep(iter.calls,K-1), out.calls)
# Innermost function
mu.all <- matrix(NA,nc=K+1,nr=N) # EE..E()|A,X)|..), ...., E(Y|mk,A,x), Y
mu.all[,K+1] <- data[,Y]
# iterative outcome model
for(i in K:1){
data$mu <- mu.all[,i+1]
Ai_data = data
Ai_data[,a.list[[i]]] = suppressMessages({map_dfc(active_s.list[[i]], ~rep(.x, N))})
model_fun <- match.fun(fit_names[[i]])
modelfit <- model_fun(data, X = c(a.list[[i]],cum_mediators[[i]]),Y = "mu", fl_call=mu.calls[[i]])
# print(modelfit)
mu.all[,i] <- predict(modelfit, Ai_data[,c(a.list[[i]],cum_mediators[[i]])])
}
}
#### 3. propensity model ----------
if(estimation !="G"){
pro.details<- extract_model_details(Pmodel.lists[[1]])
pro.fit_names <-paste0("fl_", pro.details$fit_name)
pro.calls <- pro.details$model_call
# Nested list: propensity for p(t1|...);p(t2|t1, ...);p(t3|...)
pro.modelfits<-pmap(list(cum_mediators, cum_a.list, a.list),
function(mediator, a_predictor, a_out){
model_fun <- match.fun(pro.fit_names)
modelfit <- map2(a_predictor,a_out,
~{model_fun(data, X = c(mediator,.x) ,Y = .y, fl_call =pro.calls)})
return(modelfit)
})
# product term in the denominators of Indicator
I.model.index<- map_int(unique(flatten(cum_a.list) ), ~ which(map_lgl(flatten(cum_a.list), identical, .x))[1])
model.I<- flatten(pro.modelfits)[I.model.index]
model.I.list <-map(seq_len(ncol(active_s)), ~ model.I[which(!is.na(active_s[, .x]))])
}
#### 4. potential outcome data --------------
if(estimation == "EIF"){
phi.all <- matrix(NA,nc=K+1, nr=N) # calculation from muK to mu1
phi.all[,1] <- mu.all[,1]
for (i in K:1) {
active_i <- active_s.list[[i]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[i]], active_i, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[i]],
a_vars = a.list[[i]],
a_values = active_s.list[[i]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(i - 1)) {
if (!all(active_s[,i] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[i]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[i]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
phi.all[,i+1] = I/product.I*product.Bayes*(mu.all[,i+1]-mu.all[,i])
}
potential_data = rowSums(phi.all)
}
if(estimation=="G"){
potential_data = mu.all[,1]
}
if(estimation == "IPW"){
active_K <- active_s.list[[K]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[K]], active_K, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[K]],
a_vars = a.list[[K]],
a_values = active_s.list[[K]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(K - 1)) {
if (!all(active_s[,K] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[K]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[K]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
potential_data = I/product.I*product.Bayes*data[,Y]
}
#### 5. results --------------
out = data.frame(active = paste0(map_chr(active, ~ paste0(na.omit(.x), collapse = "")),
collapse = ";"),
value = mean(potential_data,na.rm=T),
SE = sqrt(var(potential_data,na.rm=T)/nrow(data))
)
output <- list(call = cl,
pathsFit =pathsFit,
active = active_m,
results = out,
potential_data = potential_data)
class(output) <- 'mflexPotential'
return(output)
}
#' Flexible Causal Path-Specific Effect Estimation
#'
#' This function estimates causal path-specific effects by comparing two potential outcome objects generated from the \code{flexPotential} or \code{mflexPotential} functions.
#' The effects can be estimated on different scales, including difference ("diff"), risk ratio ("risk"), and odds ratio ("oddsratio").
#' The function also supports bootstrapping for estimating confidence intervals and p-values.
#'
#' @param p1 An object or a list of objects of class \code{flexPotential} or \code{mflexPotential} generated by the \code{flexPotential} or \code{mflexPotential} function, representing one set of potential outcomes.
#' @param p0 An object or a list of objects of class \code{flexPotential} or \code{mflexPotential} generated by the \code{flexPotential} or \code{mflexPotential} function, representing another set of potential outcomes for comparison.
#' Note: \code{p1} and \code{p0} should have the same length; otherwise, one of them must contain a single potential outcome object.
#' @param scale A character string specifying the scale for effect estimation. Options are "diff" (difference), "risk" (risk ratio), and "oddsratio" (odds ratio). The default is "diff".
#' @param CI_level A numeric value indicating the confidence level for the confidence intervals, typically set between 0 and 1. The default is 0.95 for 95% confidence intervals.
#' @param nboot An optional numeric value specifying the number of bootstrap samples to draw for estimating the standard errors and confidence intervals. If NULL, no bootstrapping is performed.
#' @param m.cores An optional numeric value indicating the number of cores to use for parallel processing during bootstrapping. If NULL, the function will use a single core.
#'
#' @return An object of class \code{flexEffect}, which includes the following components:
#' \describe{
#'   \item{\code{pathsFit}}{The original \code{pathsFit} object used for the analysis.}
#'   \item{\code{results}}{A data frame containing the estimated effects for each path, including the effect size, standard error, confidence intervals, and p-values (for the "diff" scale).}
#'   \item{\code{data}}{The original data frame used for the analysis.}
#'   \item{\code{boot_results}}{If bootstrapping is performed, a data frame containing the bootstrap estimates of the effects, including standard errors, confidence intervals, and p-values.}
#'   \item{\code{call}}{The matched call to the \code{flexEffect} function.}
#' }
#'
#' @examples
#' # Example usage
#' data("singTreat")
#'
#' fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome1", cov_x = c("X1", "X2"),
#'                 M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
#'                 estimation = "EIF",
#'                 model.outcome = list(~ glm(family = gaussian())),
#'                 model.propensity = ~ bart(verbose = FALSE, ndpost = 200))
#'
#' potential_outcome1 <- flexPotential( pathsFit = fit, active = c(1, 0, 1, 1))
#' potential_outcome2 <- flexPotential( pathsFit = fit, active = c(0, 1, 0, 1))
#' potential_outcome0 <- flexPotential( pathsFit = fit, active = c(0, 0, 0, 0))
#'
#' effect_results <- flexEffect(p1 = list(potential_outcome1, potential_outcome2),
#'                              p0 = potential_outcome0, scale = "diff", CI_level = 0.95)
#'
#' @import stats purrr dplyr
#' @import SuperLearner dbarts
#' @importFrom parallel mclapply detectCores
#'
#' @export
#'
flexEffect<-function(
p1 ,
p0 ,
scale = "diff", CI_level = 0.95,
nboot = NULL, m.cores = NULL){
# environment
Call <- match.call()
# 1. check the input p1 and p0 -----
## (1) to check one input -------
if(is.null(p1$call)){len_p1 <- length(p1) }else{
p1 = list(p1)
len_p1 <- length(p1)}
if(is.null(p0$call)){len_p0 <- length(p0)}else{
p0 = list(p0)
len_p0 <- length(p0)}
if (len_p1 != len_p0) {
# 2. If lengths differ, one of them must have exactly one input
if (len_p1 == 1) {
p1 <- rep(p1, len_p0)
} else if (len_p0 == 1) {
p0 <- rep(p0, len_p1)
} else {
stop("p1 and p0 must have the same length or one of them must have only one input.")
}
}
## (2). Check that the Call components of p1, and p0 ----
# same class flexPotential or mflexPotential
class_p = map_chr(c(p1, p0), ~ class(.x) )
if(length(unique(class_p))!=1){
stop("All elements in p1 and p0 must have the same class.")
}
if(!unique(class_p)%in% c("flexPotential","mflexPotential") ){
stop("All elements in p1 and p0 the class must be either 'flexPotential' or 'mflexPotential'.")
}
# they have the pathsFit
pathsFit_p1 <- map(p1, ~.x$pathsFit)
pathsFit_p0 <- map(p0, ~.x$pathsFit)
if (!all(map_lgl(pathsFit_p1, ~identical(.x, pathsFit_p0[[1]])))) {
stop("All inputs in p1 and p0 must have the same 'pathsFit' in their Call component.")
}
# 2. the results of EIF
results <- map2_dfr(p1, p0, ~{
active <- paste(.x$results$active , "vs" ,.y$results$active)
if (scale == "diff"){
diff <- .x$potential_data - .y$potential_data
Effect <- mean(diff, na.rm = TRUE)
SE <- sqrt(var(diff, na.rm = TRUE) / length(diff))
CI.lower <- Effect + qnorm((1 - CI_level) / 2) * SE
CI.upper <- Effect - qnorm((1 - CI_level) / 2) * SE
P.value <- round(2 * (1 - pnorm(abs(Effect / SE))), 4)
# Return the results as a data frame row
out<-data.frame(active =active,Effect = Effect, SE = SE, CI.lower = CI.lower, CI.upper = CI.upper, P.value = P.value)
}
if (scale == "risk"){
Effect <- mean(.x$potential_data, na.rm = TRUE)/mean(.y$potential_data, na.rm = TRUE)
# Return the results as a data frame row
out<-data.frame(active =active,Effect = Effect)
}
if (scale == "oddsratio"){
m1 <- mean(.x$potential_data, na.rm = TRUE)
m2 <- mean(.y$potential_data, na.rm = TRUE)
Effect <- (m1/(1-m1))/(m2/(1-m2))
out<- data.frame(active =active,Effect = Effect)
}
return(out) })
data_raw = p1[[1]]$pathsFit$data; pathsFit = p1[[1]]$pathsFit
out<- list(pathsFit =pathsFit,
results =arrange(results,by=active),
data = data_raw)
# 2. get the summary of identical calculation ----
# check_SuperLearner return warning
if(!is.null(nboot)){
# aviod replicate calculation to save time
call_p1 <- map(p1, ~.x$call)
call_p0 <- map(p0, ~.x$call)
call_all<-unique(c(call_p1,call_p0))
index_p1 <- map_int(call_p1, function(index) {
which(map_lgl(call_all, ~ identical(.x, index)))
})
index_p0 <- map_int(call_p0, function(index) {
which(map_lgl(call_all, ~ identical(.x, index)))
})
# bootstrap
if (is.numeric(m.cores)) {
m.cores.detected <- parallel::detectCores()
if(m.cores > m.cores.detected) m.cores <- m.cores.detected
boot.list <- parallel::mclapply(seq_len(nboot), function(i) {
one_boot.flexEffect(data_raw, pathsFit, call_all, index_p1, index_p0)}, mc.cores = m.cores)
}else{
boot.list = map(seq_len(nboot),
~one_boot.flexEffect(data_raw, pathsFit, call_all, index_p1, index_p0))
}
results.combine <- map_dfr(boot.list, ~ .x , .id = "source")
output<- results.combine %>%
mutate(
#  scale = scale,
Effect = case_when(scale == "diff"~ (value1-value0),
scale == "risk"~ (value1/value0),
scale == "oddsratio"~ (value1/(1-value1))/(value0/(1-value0)))
) %>%
group_by(active) %>%
summarise(
boot.SE = sd(Effect),
boot.CI.lower = quantile(Effect, probs = (1-CI_level)/2),
boot.CI.upper = quantile(Effect, probs = 1-(1-CI_level)/2)) %>%
full_join(select(results, active, Effect), by = join_by(active)) %>%
mutate(boot.P.value = round(2*(1-pnorm(abs(Effect)/boot.SE)),4),
nboot = nboot) %>%
relocate(Effect, .after = active) %>% as.data.frame()
out$boot_results <- output
}
out$call <- Call
class(out) <- "flexEffect"
return(out)
}
mp1<-mflexPotential(active = list(a1=c(0,1,0,0,1,0,0),
a2=c(1,0,1,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
#' Causal Path-Specific Potential Outcome Calculation for Multiple Treatments
#'
#' This function calculates causal path-specific potential outcomes for multiple treatments.
#' Users can specify different levels of each treatment for each mediator (M1 to Mk) and directly define the outcome (Y) to represent the potential outcome for a single path or several combined paths.
#' The function supports various estimation methods, including EIF (Efficient Influence Function), IPW (Inverse Probability Weighting), and G-computation.
#'
#' @param data A data frame containing all the variables required for the analysis.
#' @param pathsFit An object of class \code{pathsFit}, which is the output from the \code{pathsFit} function, containing the necessary fitted models.
#' @param active A list of vectors specifying the active values for each mediator (M1 to Mk) and the direct value setting for the outcome (Y).
#' Each vector in the list corresponds to the setting of one treatment for the mediators. The order of treatments in the list should match the order of mediators.
#'
#' @return An object of class \code{mflexPotential}, which includes the following components:
#' \describe{
#'   \item{\code{call}}{The matched call to the \code{mflexPotential} function.}
#'   \item{\code{pathsFit}}{The original \code{pathsFit} object used for the analysis.}
#'   \item{\code{active}}{A matrix representing the active values used for each mediator and the direct outcome.}
#'   \item{\code{results}}{A data frame containing the average potential outcome (value) and its standard error (SE).}
#'   \item{\code{potential_data}}{A vector containing the calculated potential outcomes for each observation in the dataset.}
#' }
#'
#' @examples
#' # Example usage
#' data("multiTreat")
#'
#' mfit <- pathsFit(
#'   data = multiTreat, Y = "Y", A = c("t1", "t2", "t3"), cov_x = "X", estimation = "EIF",
#'   M.list = list(M1 = 'm1', M2 = 'm2', M3 = 'm3', M4 = 'm4', M5 = 'm5', M6 = 'm6'),
#'   model.propensity = list(~ glm(family = binomial())),
#'   model.outcome = list(~ SuperLearner(SL.library = "SL.mean", family = gaussian()))
#' )
#'
#' potential_outcome <- mflexPotential(
#'   pathsFit = mfit,
#'   active = list(
#'     c(0, 1, 0, 0, 1, 0, 0),      # Treatment1
#'     c(1, 0, 1, 1, 1, 0, 0),      # Treatment2
#'     c(NA, NA, NA, 1, 0, 0, 0)    # Treatment3
#'   )
#' )
#'
#' @import stats purrr
#' @import SuperLearner dbarts
#'
#' @export
mflexPotential <-  function(
pathsFit,active
){
cl <- match.call()
list2env(pathsFit, envir = environment())
#### 1. data preparation ---------
## cov_x and mediators
N= nrow(data)
Km <- length(M.list)
# combine mediators
# mediators for model
active_m <- do.call(rbind, active)
M.index <- mcreate_index(active_m)[-(Km + 1)]
M.list_s <- combine_item(M.list, M.index)
cum_mediators <- cumulate_vars(c(cov_x,M.list_s))
# treatment value for model
active_s <- simplify_active(active_m)
# treatment variables list; assigned value list
a.list <- map(seq_len(ncol(active_s)), ~ A[which(!is.na(active_s[, .x]))])
active_s.list<-map(1:ncol(active_s), ~ as.numeric(na.omit(active_s[, .x])))
# cumulative expression for model
cum_a.list <- map(a.list,~cumulate_vars(.x,first_null = T))
cum_active_s.list<-map(active_s.list,~cumulate_vars(.x,first_null = T))
K = length(cum_mediators)
#### 2. outcome model  ----------
if(estimation != "IPW"){
out.details<- map(Omodel.lists,extract_model_details)
out.fit_names <- map(out.details, ~ paste0("fl_", .x$fit_name))
out.calls <-  map(out.details, "model_call")
iter.details<- map(Imodel.lists,extract_model_details)
iter.fit_names <- map(iter.details, ~ paste0("fl_", .x$fit_name))
iter.calls <- map(iter.details, "model_call")
iter.calls <-map(iter.calls, ~ replace_family(.x))
fit_names <- c(rep(iter.fit_names,K-1), out.fit_names)
mu.calls <- c(rep(iter.calls,K-1), out.calls)
# Innermost function
mu.all <- matrix(NA,nc=K+1,nr=N) # EE..E()|A,X)|..), ...., E(Y|mk,A,x), Y
mu.all[,K+1] <- data[,Y]
# iterative outcome model
for(i in K:1){
data$mu <- mu.all[,i+1]
Ai_data = data
Ai_data[,a.list[[i]]] = suppressMessages({map_dfc(active_s.list[[i]], ~rep(.x, N))})
model_fun <- match.fun(fit_names[[i]])
modelfit <- model_fun(data, X = c(a.list[[i]],cum_mediators[[i]]),Y = "mu", fl_call=mu.calls[[i]])
# print(modelfit)
mu.all[,i] <- predict(modelfit, Ai_data[,c(a.list[[i]],cum_mediators[[i]])])
}
}
#### 3. propensity model ----------
if(estimation !="G"){
pro.details<- extract_model_details(Pmodel.lists[[1]])
pro.fit_names <-paste0("fl_", pro.details$fit_name)
pro.calls <- pro.details$model_call
# Nested list: propensity for p(t1|...);p(t2|t1, ...);p(t3|...)
pro.modelfits<-pmap(list(cum_mediators, cum_a.list, a.list),
function(mediator, a_predictor, a_out){
model_fun <- match.fun(pro.fit_names)
modelfit <- map2(a_predictor,a_out,
~{model_fun(data, X = c(mediator,.x) ,Y = .y, fl_call =pro.calls)})
return(modelfit)
})
# product term in the denominators of Indicator
I.model.index<- map_int(unique(flatten(cum_a.list) ), ~ which(map_lgl(flatten(cum_a.list), identical, .x))[1])
model.I<- flatten(pro.modelfits)[I.model.index]
model.I.list <-map(seq_len(ncol(active_s)), ~ model.I[which(!is.na(active_s[, .x]))])
}
#### 4. potential outcome data --------------
if(estimation == "EIF"){
phi.all <- matrix(NA,nc=K+1, nr=N) # calculation from muK to mu1
phi.all[,1] <- mu.all[,1]
for (i in K:1) {
active_i <- active_s.list[[i]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[i]], active_i, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[i]],
a_vars = a.list[[i]],
a_values = active_s.list[[i]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(i - 1)) {
if (!all(active_s[,i] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[i]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[i]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
phi.all[,i+1] = I/product.I*product.Bayes*(mu.all[,i+1]-mu.all[,i])
}
potential_data = rowSums(phi.all)
}
if(estimation=="G"){
potential_data = mu.all[,1]
}
if(estimation == "IPW"){
active_K <- active_s.list[[K]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[K]], active_K, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[K]],
a_vars = a.list[[K]],
a_values = active_s.list[[K]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(K - 1)) {
if (!all(active_s[,K] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[K]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[K]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
potential_data = I/product.I*product.Bayes*data[,Y]
}
#### 5. results --------------
out = data.frame(active = paste0(map_chr(active, ~ paste0(na.omit(.x), collapse = "")),
collapse = ";"),
value = mean(potential_data,na.rm=T),
SE = sqrt(var(potential_data,na.rm=T)/nrow(data))
)
output <- list(call = cl,
pathsFit =pathsFit,
active = active_m,
results = out,
potential_data = potential_data)
class(output) <- 'mflexPotential'
return(output)
}
mp1<-mflexPotential(active = list(a1=c(0,1,0,0,1,0,0),
a2=c(1,0,1,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
mp2<-mflexPotential(active = list(a1=c(0,0,0,0,1,0,0),
a2=c(0,0,0,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
flexEffect(p1 = list(mp1,mp2),
p0 = mp2,
scale = "diff", CI_level = 0.95,
nboot =2 , m.cores = 8)
remove.packages("flexPaths")
