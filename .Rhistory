Ai_data[,a.list[[i]]] = suppressMessages({map_dfc(active_s.list[[i]], ~rep(.x, N))})
model_fun <- match.fun(fit_names[[i]])
modelfit <- model_fun(data, X = c(a.list[[i]],cum_mediators[[i]]),Y = "mu", fl_call=mu.calls[[i]])
# print(modelfit)
mu.all[,i] <- predict(modelfit, Ai_data[,c(a.list[[i]],cum_mediators[[i]])])
}
}
#### 3. propensity model ----------
if(estimation !="G"){
pro.details<- extract_model_details(Pmodel.lists[[1]])
pro.fit_names <-paste0("fl_", pro.details$fit_name)
pro.calls <- pro.details$model_call
# Nested list: propensity for p(t1|...);p(t2|t1, ...);p(t3|...)
pro.modelfits<-pmap(list(cum_mediators, cum_a.list, a.list),
function(mediator, a_predictor, a_out){
model_fun <- match.fun(pro.fit_names)
modelfit <- map2(a_predictor,a_out,
~{model_fun(data, X = c(mediator,.x) ,Y = .y, fl_call =pro.calls)})
return(modelfit)
})
# product term in the denominators of Indicator
I.model.index<- map_int(unique(flatten(cum_a.list) ), ~ which(map_lgl(flatten(cum_a.list), identical, .x))[1])
model.I<- flatten(pro.modelfits)[I.model.index]
model.I.list <-map(seq_len(ncol(active_s)), ~ model.I[which(!is.na(active_s[, .x]))])
}
#### 4. potential outcome data --------------
if(estimation == "EIF"){
phi.all <- matrix(NA,nc=K+1, nr=N) # calculation from muK to mu1
phi.all[,1] <- mu.all[,1]
for (i in K:1) {
active_i <- active_s.list[[i]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[i]], active_i, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[i]],
a_vars = a.list[[i]],
a_values = active_s.list[[i]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(i - 1)) {
if (!all(active_s[,i] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[i]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[i]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
phi.all[,i+1] = I/product.I*product.Bayes*(mu.all[,i+1]-mu.all[,i])
}
potential_data = rowSums(phi.all)
}
if(estimation=="G"){
potential_data = mu.all[,1]
}
if(estimation == "IPW"){
active_K <- active_s.list[[K]]
## indicator I(t1 = , t2 =, ...)
Indicator_expr <- paste(map2(a.list[[K]], active_K, ~ paste0(.x, "==", .y)),
collapse = " & ")
I = eval(parse(text = Indicator_expr),envir = data)
## product.I:
product.I = prod_assign_modellist(model_list = model.I.list[[K]],
a_vars = a.list[[K]],
a_values = active_s.list[[K]] )
## Bayes density ratio
product.Bayes <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(K - 1)) {
if (!all(active_s[,K] == active_s[,j],na.rm = T) ) {
product.Bayes <- product.Bayes *
(  prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[j]]) /  # use the value of itself to predict
prod_assign_modellist(pro.modelfits[[j+1]],a.list[[j]],active_s.list[[K]])    # use the value of i to predict
)*
(prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[K]])/
prod_assign_modellist(pro.modelfits[[j]],a.list[[j]],active_s.list[[j]]))
}
}
# sub EIF function for each row
potential_data = I/product.I*product.Bayes*data[,Y]
}
#### 5. results --------------
out = data.frame(active = paste0(map_chr(active, ~ paste0(na.omit(.x), collapse = "")),
collapse = ";"),
value = mean(potential_data,na.rm=T),
SE = sqrt(var(potential_data,na.rm=T)/nrow(data))
)
output <- list(call = cl,
pathsFit =pathsFit,
active = active_m,
results = out,
potential_data = potential_data)
class(output) <- 'mflexPotential'
return(output)
}
mp1<-mflexPotential(active = list(a1=c(0,1,0,0,1,0,0),
a2=c(1,0,1,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
mp2<-mflexPotential(active = list(a1=c(0,0,0,0,1,0,0),
a2=c(0,0,0,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
flexEffect(p1 = list(mp1,mp2),
p0 = mp2,
scale = "diff", CI_level = 0.95,
nboot =2 , m.cores = 8)
remove.packages("flexPaths")
library(usethis)
library(devtools)
library(roxygen2)
library(flexPaths)
devtools::document()
devtools::build()
library(flexPaths)
data("singTreat")
data("multiTreat")
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "IPW",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
effect_results1 <- pathsEffect(pathsFit = EIF_fit, decomposition = "refer0", scale = "risk", CI_level = 0.95)
effect_results2 <- pathsEffect(pathsFit = EIF_fit, decomposition = "refer0", scale = "diff", CI_level = 0.95, nboot = 5, m.cores = 6)
effect_results3 <- pathsEffect( pathsFit = EIF_fit, decomposition = "sequential", scale = "diff", CI_level = 0.95, nboot = , m.cores = 6)
potential_outcome1 <- flexPotential(pathsFit = EIF_fit, active = c(1, 0, 1, 1))
potential_outcome0 <- flexPotential(pathsFit = EIF_fit, active = c(0, 0, 0, 0))
potential_outcome2<- flexPotential(pathsFit = EIF_fit, active = c(1, 0, 0, 1))
flex_results1 <- flexEffect(p1 = list(potential_outcome1, potential_outcome2),
p0 = potential_outcome0, scale = "diff", CI_level = 0.95,nboot = 5)
flex_results2 <- flexEffect(p1 = list(potential_outcome1, potential_outcome2),
p0 = potential_outcome0, scale = "diff", CI_level = 0.95)
data("multiTreat")
mfit<- pathsFit(data = multiTreat,
Y = "Y",
A = c("t1","t2","t3"),
cov_x = "X",
M.list = list(
M1 = 'm1',
M2 = 'm2',
M3 = 'm3',
M4 = 'm4',
M5 = 'm5',
M6 = 'm6'
),
estimation = "EIF",
model.propensity =list( ~  glm(family = binomial())),
model.outcome = list( ~SuperLearner(SL.library = "SL.mean",family = gaussian())),
model.iter  = list(~glm(family = gaussian()))
)
mp1<-mflexPotential(active = list(a1=c(0,1,0,0,1,0,0),
a2=c(1,0,1,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
mp2<-mflexPotential(active = list(a1=c(0,0,0,0,1,0,0),
a2=c(0,0,0,1,1,0,0),
a3=c(NA,NA,NA,1,0,0,0)),mfit)
flexEffect(p1 = list(mp1,mp2),
p0 = mp2,
scale = "diff", CI_level = 0.95,
nboot =2 , m.cores = 8)
mp2
mp1
flex_results1
flex_results2
potential_outcome1
effect_results1
effect_results2
effect_results3
devtools::document()
devtools::build()
devtools::document()
devtools::build()
d<- ~tpmd(family=binomial())
extract_model_details(d)
f<-extract_model_details(d)$model_call
class(f)
f$data <- quote(datadd)
f
library(usethis)
library(devtools)
library(roxygen2)
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "IPW",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
library(flexPaths)
data("singTreat")
data("multiTreat")
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "IPW",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
EIF_fit$Omodel.lists
EIF_fit$Imodel.lists
active = c(1, 0, 0, 1)
list2env(EIF_fit, envir = environment())
#### 1. data preparation ---------
# A is a binary;
I = data[[A]]
# counterfactual data
A0_data <- A1_data <- data;
A0_data[[A]] <- 0; A1_data[[A]] <- 1
### cov_x and mediators
Km <- length(M.list)    # have Km mediators
if((Km + 1)!=length(active)){
stop("Error: The length of 'active' must be equal to the length of 'M.list' + 1.
Please ensure both inputs are of the same length.")
}
# combine the same value of path
M.index <- create_index(active)[-(Km + 1)]
active = c(1, 0, 0, 1)
# combine the same value of path
M.index <- create_index(active)[-(Km + 1)]
# Get a list of all R files in the folder
r_files <- list.files(path = "R", pattern = "\\.R$", full.names = TRUE)
walk(r_files, source)
active
#### 1. data preparation ---------
# A is a binary;
I = data[[A]]
# counterfactual data
A0_data <- A1_data <- data;
A0_data[[A]] <- 0; A1_data[[A]] <- 1
### cov_x and mediators
Km <- length(M.list)    # have Km mediators
if((Km + 1)!=length(active)){
stop("Error: The length of 'active' must be equal to the length of 'M.list' + 1.
Please ensure both inputs are of the same length.")
}
# combine the same value of path
M.index <- create_index(active)[-(Km + 1)]
M.index
# combine the same value of path
M.index <- create_index(active)[-(Km + 1)]
M.list_s <- combine_item(M.list, M.index)
active_s <- rle(active)$values
cum_mediators <- Reduce(c, c(list(cov_x), M.list_s), accumulate = TRUE)
cum_mediators
K = length(cum_mediators) # K-1 combined mediators and cov
Imodel.lists
M.index
unique(M.index[M.index!=0])
K-1
M.index
Omodel
Omodel.lists
M.index
Omodel <-  Omodel.lists[max(c(1,unique(M.index[M.index!=0])+1))]
Omodel
Imodel <- Imodel.lists[c(1, unique(M.index[M.index!=0])[-(K-1)]+1)]
Imodel
#' Causal Path-Specific Potential Outcome Calculation for Single Treatment
#'
#' This function calculates causal path-specific potential outcomes for a single binary treatment.
#' Users can specify different levels of the treatment for each mediator (M1, M2, ..., Mk) and directly define the outcome (Y) to represent the potential outcome for a specific path or a combination of paths.
#' The function supports various estimation methods, including EIF (Efficient Influence Function), IPW (Inverse Probability Weighting), and G-computation.
#'
#' @param data A data frame containing all the variables required for the analysis.
#' @param pathsFit An object of class \code{pathsFit}, which is the output from the \code{pathsFit} function, containing the necessary fitted models and data.
#' @param active A vector specifying the active values for each mediator (M1 to Mk) and the direct value setting for the outcome (Y) in order.
#' The last value in the vector corresponds to the treatment value for Y. The length of this vector should be equal to the number of mediators plus one (for the direct effect on Y).
#'
#' @return An object of class \code{flexPotential}, which includes the following components:
#' \describe{
#'   \item{\code{call}}{The matched call to the \code{flexPotential} function.}
#'   \item{\code{pathsFit}}{The original \code{pathsFit} object used for the analysis.}
#'   \item{\code{active}}{A vector representing the active values used for each mediator and the direct outcome.}
#'   \item{\code{results}}{A data frame containing the calculated potential outcome (value) and its standard error (SE).}
#'   \item{\code{potential_data}}{A vector containing the calculated potential outcomes for each observation in the dataset.}
#' }
#'
#' @examples
#' # Example usage
#' data("singTreat")
#'
#' fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome1", cov_x = c("X1", "X2"),
#'                 M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
#'                 estimation = "EIF",
#'                 model.outcome = list(~ glm(family = gaussian())),
#'                 model.propensity = ~ bart(verbose = FALSE, ndpost = 200))
#'
#' potential_outcome <- flexPotential(
#'   pathsFit = fit,
#'   active = c(1, 0, 1, 1)  # Setting active values for M1, M2, M3, and Y
#' )
#'
#' @import stats purrr
#' @import SuperLearner dbarts
#'
#' @export
#'
#'
flexPotential <-  function(
pathsFit,active  # M1, M2, M3,...,Direc
){
cl <- match.call()
list2env(pathsFit, envir = environment())
#### 1. data preparation ---------
# A is a binary;
I = data[[A]]
# counterfactual data
A0_data <- A1_data <- data;
A0_data[[A]] <- 0; A1_data[[A]] <- 1
### cov_x and mediators
Km <- length(M.list)    # have Km mediators
if((Km + 1)!=length(active)){
stop("Error: The length of 'active' must be equal to the length of 'M.list' + 1.
Please ensure both inputs are of the same length.")
}
# combine the same value of path
M.index <- create_index(active)[-(Km + 1)]
M.list_s <- combine_item(M.list, M.index)
active_s <- rle(active)$values
cum_mediators <- Reduce(c, c(list(cov_x), M.list_s), accumulate = TRUE)
K = length(cum_mediators) # K-1 combined mediators and cov
#### 2. propensity model ----------
if(estimation != "G"){
Pmodel = Pmodel.lists[c(1,unique(M.index[M.index!=0])+1)]
pro.details<- map(Pmodel,extract_model_details)
pro.fit_names <- map(pro.details, ~ paste0("fl_", .x$fit_name))
pro.calls <- map(pro.details, "model_call")
pro.modelfits<- pmap(list(cum_mediators, pro.fit_names, pro.calls),
function(cum_mediators, pro.fit_names, pro.calls){
model_fun <- match.fun(pro.fit_names)
model<-model_fun(data, X = cum_mediators,Y = A, fl_call=pro.calls)
return(model)
})
# P(A=1|cov_X); P(A=1|M1,cov_X); P(A=1|M1,...,MK,X)
gA1_Mk_X.list <- map2(cum_mediators, pro.modelfits, ~ {predict(.y, newdata = data[,.x, drop=FALSE])})
# P(A=0|cov_X); P(A=0|M1,cov_X); P(A=0|M1,...,MK,X)
gA0_Mk_X.list <- map(gA1_Mk_X.list, ~ {1-.x})
}
#### 3. outcome model modelO.list ----------
# check only one
if(estimation !="IPW"){
Omodel <-  Omodel.lists[max(c(1,unique(M.index[M.index!=0])+1))]
out.details<-  map(Omodel,extract_model_details)
out.fit_names <- map(out.details, ~ paste0("fl_", .x$fit_name))
out.calls <- map(out.details, "model_call")
Imodel <- Imodel.lists[c(1, unique(M.index[M.index!=0])[-(K-1)]+1)]
iter.details<- map(Imodel,extract_model_details)
iter.fit_names <- map(iter.details, ~ paste0("fl_", .x$fit_name))
iter.calls <- map(iter.details, "model_call")
iter.calls <-map(iter.calls, ~ replace_family(.x))
fit_names <- c(iter.fit_names, out.fit_names)
mu.calls <- c(iter.calls, out.calls)
# Innermost function
mu.all <- matrix(NA,nc=K+1,nr=nrow(data)) # EE..E()|A,X)|..), ...., E(Y|mk,A,x), Y
mu.all[,K+1] <- data[,Y]
# iterative outcome model
for(i in K:1){
data$mu <- mu.all[,i+1]
model_fun <- match.fun(fit_names[[i]])
modelfit <- model_fun(data, X = c(A,cum_mediators[[i]]),Y = "mu", fl_call=mu.calls[[i]])
Ai_data <- if(active_s[i]==1){ A1_data }else{ A0_data }
mu.all[,i] <- predict(modelfit, Ai_data[,c(A,cum_mediators[[i]])])
}
}
#### 4. calculate phi() and Pn( ) ------
if(estimation == "EIF"){
# phi() is a value for each row of EIF formula
phi.all <- matrix(NA,nc=K+1,nr=nrow(data)) # calculation from muK to mu1
phi.all[,1] <- mu.all[,1]
for (i in K:1) {
if(active_s[i] == 1){
gA_X <- gA1_Mk_X.list[[1]]
ratio_index = -1
}else{
gA_X <- gA0_Mk_X.list[[1]]
ratio_index = 1
}
# Bayes density ratio
product <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(i - 1)) {
if (active_s[i] != active_s[j]) {
product <- product *
( (gA1_Mk_X.list[[j+1]]/gA0_Mk_X.list[[j+1]])*(gA0_Mk_X.list[[j]] / gA1_Mk_X.list[[j]]) )^(ratio_index)
}
}
# sub EIF function for each row
phi.all[,i+1] = (I == active_s[i])/gA_X*product*(mu.all[,i+1]-mu.all[,i])
}
potential_data = rowSums(phi.all)
}
if(estimation == "G"){
potential_data = mu.all[,1]
}
if(estimation =="IPW"){
if(active_s[K] == 1){ gA_X <- gA1_Mk_X.list[[1]]; ratio_index = -1
}else{ gA_X <- gA0_Mk_X.list[[1]]; ratio_index = 1 }
# Bayes density ratio
product <- 1 # Initialize the product
# Iterate through previous indices j < i
for (j in seq_len(K - 1)) {
if (active_s[K] != active_s[j]) {
product <- product *
( (gA1_Mk_X.list[[j+1]]/gA0_Mk_X.list[[j+1]])*(gA0_Mk_X.list[[j]] / gA1_Mk_X.list[[j]]) )^(ratio_index)
}
}
potential_data = (I == active_s[K])/gA_X*product*data[,Y]
}
results = data.frame(active = paste0(as.character(active), collapse = ""),
value = mean(potential_data,na.rm=T),
SE = sqrt(var(potential_data,na.rm=T)/nrow(data))
)
output <- list(call = cl,
pathsFit =pathsFit,
active = active,
results = results,
potential_data = potential_data)
class(output) <- 'flexPotential'
return(output)
}
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
potential_outcome1 <- flexPotential(pathsFit = EIF_fit, active = c(1, 0, 1, 1))
library(flexPaths)
walk(r_files, source)
data("singTreat")
data("multiTreat")
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
effect_results1 <- pathsEffect(pathsFit = EIF_fit, decomposition = "refer0", scale = "risk", CI_level = 0.95)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
library(flexPaths)
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
data("singTreat")
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
effect_results1 <- pathsEffect(pathsFit = EIF_fit, decomposition = "refer0", scale = "risk", CI_level = 0.95)
devtools::document()
devtools::build()
# Get a list of all R files in the folder
r_files <- list.files(path = "R", pattern = "\\.R$", full.names = TRUE)
walk(r_files, source)
EIF_fit <- pathsFit(data = singTreat, A = "treat", Y = "outcome2", cov_x = c("X1", "X2"),
M.list = list(M1 = "med1", M2 = c('med2_1', 'med2_2'), M3 = 'med3'),
estimation = "EIF",
model.outcome = list(cov_x= ~ glm(formula =  outcome2~X1*X2+treat, family =binomial() ),
M1 =~ glm(formula =  outcome2~X1*X2+med1+treat, family =binomial() ),
M2 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+treat, family =binomial()),
M3 =~ glm(formula =  outcome2~X1*X2+med1+med2_1+med2_2+med3+treat, family =binomial())
),
model.propensity = ~ bart(verbose = FALSE, ndpost = 200)
)
potential_outcome1 <- flexPotential(pathsFit = EIF_fit, active = c(1, 0, 1, 1))
potential_outcome1
